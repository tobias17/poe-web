<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <title>SVG Canvas Helper</title>
   <style>
      body {
         background-color: #242424;
         margin: 0;
         padding: 0;
         display: flex;
         justify-content: center;
         font-family: Arial, sans-serif;
      }
      #svg-container {
         width: 100%;
         max-width: 1200px;
         position: fixed;
         top: 0;
         left: 0;
         right: 0;
         margin: 0 auto;
      }
      svg {
         width: 100%;
         height: auto;
      }
      .svg_text {
         -webkit-user-select: none;
         -moz-user-select: none;
         -ms-user-select: none;
         user-select: none;
      }
   </style>
</head>
<body>
   <div id="svg-container">
      <svg id="canvas" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1400 800">
         <!-- Elements will be dynamically added here -->
      </svg>
   </div>

   <script>

// Get the SVG canvas
const canvas = document.getElementById('canvas');
const print = console.log

var selected_slider = null
function global_on_mouse_move(e) {
   if (selected_slider == null) {
      return
   }
   if (!e.buttons) {
      selected_slider = null
      return
   }
   const g = selected_slider
   const CTM = canvas.getScreenCTM();
   const mouse_x = (e.clientX - CTM.e) / CTM.a
   const perc = Math.max(0.0, Math.min(1.0, (mouse_x- g.lx) / g.dx))
   const index = Math.floor(perc * g.range + 0.5)
   const cx = g.lx + g.dx * (index / g.range)
   for (knob of g.knobs) {
      knob.setAttribute("cx", cx)
   }
   g.update_data(index + g.min)
   // print(e)
}
canvas.onmousemove = global_on_mouse_move



/************************/
/***    Common Lib    ***/
/************************/
function loadImage(x, y, href) {
   const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
   image.setAttribute('x', x);
   image.setAttribute('y', y);
   image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', href);
   canvas.appendChild(image);
   return image;
}
function group(x, y, attrs={}) {
   return Object.assign(attrs, {
      tag: 'g',
      x: x,
      y: y,
   })
}
function circle(cx, cy, r, color, attrs={}) {
   return Object.assign(attrs, {
      tag: 'circle',
      cx: cx,
      cy: cy,
      r: r,
      fill: color,
   })
}
function rectangle(x, y, w, h, color, attrs={}) {
   return Object.assign(attrs, {
      tag: 'rect',
      x: x,
      y: y,
      width: w,
      height: h,
      fill: color,
   })
}
function create(attrs, parent=null) {
   const item = document.createElementNS('http://www.w3.org/2000/svg', attrs.tag);
   for (key in attrs) {
      if (key != "tag") item.setAttribute(key, attrs[key])
   }
   (parent == null ? canvas : parent).appendChild(item);
   return item;
}
 
const FONT_SIZE = 14



/*************************/
/***   Text Elements   ***/
/*************************/
function __create_text_elements(text, x, y, font_size, color) {
   const text_element = document.createElementNS('http://www.w3.org/2000/svg', 'text');
   text_element.setAttribute('x', x);
   text_element.setAttribute('y', y);
   text_element.setAttribute('text-anchor', 'middle');
   text_element.setAttribute('dominant-baseline', 'middle');
   text_element.setAttribute('font-size', font_size);
   text_element.setAttribute('class', 'svg_text')
   canvas.appendChild(text_element);

   var original = text
   var in_section = false
   var data = {}
   while (text.length > 0) {
      if (in_section) {
         var index = text.indexOf("}")
         if (index < 0) {
            console.error(`unmatched brackets: '${original}'`)
            return null
         }
         var key = text.slice(0, index)
         if ( !(key in data) ) {
            data[key] = []
         }
         const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan')
         tspan.setAttribute('fill', color)
         tspan.textContent = `[${key}]`
         data[key].push(tspan)
         text_element.appendChild(tspan)
         text = text.slice(index + 1)
         in_section = false
      } else {
         var index = text.indexOf("${")
         var chunk = index < 0 ? text : text.slice(0, index)
         const key = "color"
         if ( !(key in data) ) {
            data[key] = []
         }
         const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan')
         tspan.setAttribute('fill', color)
         tspan.textContent = chunk
         data[key].push(tspan)
         text_element.appendChild(tspan)
         text = index < 0 ? "" : text.slice(index + 2)
         in_section = true
      }
   }
   return data
}

/*************************/
/***  Slider Elements  ***/
/*************************/
function __create_slider(cx, cy, width, min, max, color, value) {
   const SLIDER_RADIUS = 2.5
   const SLIDER_COLOR  = "#242424"
   const KNOB_RADIUS   = 9
   const KNOB_COLOR    = "#696969"

   const lx = cx-width/2
   const rx = cx+width/2
   create(rectangle(lx, cy-SLIDER_RADIUS, width, 2*SLIDER_RADIUS, SLIDER_COLOR))
   create(circle(lx, cy, SLIDER_RADIUS, SLIDER_COLOR))
   create(circle(rx, cy, SLIDER_RADIUS, SLIDER_COLOR))

   const vx = lx + (rx - lx) * ((value - min) / (max - min))

   const g = create(group(0, 0))
   const knob_outer = create(circle(vx, cy, KNOB_RADIUS, KNOB_COLOR), g)
   const knob_inner = create(circle(vx, cy, SLIDER_RADIUS, color), g)
   g.onmousedown = () => (selected_slider = g)
   g.min = min
   g.range = (max-min)
   g.lx = lx
   g.dx = (rx-lx)
   g.knobs = [knob_outer, knob_inner]
   return g
}

/************************/
/***    Stats Page    ***/
/************************/
function __create_stats_page(x, y, width, rows, global_name, global_color) {
   const SECTION_HEIGHT = 22
   var usable_width = width * 0.75
   const background = create(rectangle(x, y, width, 0, '#0f0f0f'))
   const cx = x + width/2
   const BUFFER = 0.3 * SECTION_HEIGHT

   const starts = {}
   const texts  = []
   const calcs  = {}
   const curr_v = {}
   function update_data(key, value) {
      curr_v[key] = value
      for (t of texts) {
         for (k in t) {
            if (k == key) {
               for (ts of t[k]) {
                  ts.textContent = value
               }
            }
         }
      }
      if (key in calcs) {
         for (calc of calcs[key]) {
            calc()
         }
      }
   }

   var curr_y = y + BUFFER + SECTION_HEIGHT
   for (row of rows) {
      if (row.type == "text") {
         const ret = __create_text_elements(row.value, cx, curr_y, FONT_SIZE, row.color)
         if (ret != null) {
            texts.push(ret)
         }
      } else if (row.type == "slider") {
         const g = __create_slider(cx, curr_y, usable_width, row.min, row.max, row.color, row.default)
         const row_id = row.id
         g.update_data = (v) => update_data(row_id, v)
         starts[row.id] = { color:row.color, value:row.default }
         curr_v[row.id] = row.default
      } else if (row.type == "calc") {
         const row_id = row.id
         const from = row.from
         const func = row.func
         var color =
            row.id == global_name
               ? global_color
               : "color" in row
                  ? row.color
                  : from.length == 1
                     ? starts[from].color
                     : null
         if (color == null) {
            console.error(`could not determine color for calc '${row_id}'`)
            continue
         }

         function update_calc() {
            const params = []
            for (key of from) {
               params.push(curr_v[key])
            }
            const new_value = func(...params)
            if (new_value == null) {
               console.error(`got null result from ${row_id}, params=${params}`)
            } else {
               update_data(row_id, new_value)
            }
         }
         for (key of row.from) {
            if ( !(key in calcs) ) {
               calcs[key] = []
            }
            calcs[key].push(update_calc)
         }
         update_calc()
         starts[row.id] = { color:color, value:curr_v[row.id] }
         curr_y -= SECTION_HEIGHT
      } else if (row.type == "gap") {
         // pass
      } else {
         console.error(`got invalid row['type'] value '${row.type}'`)
      }
      curr_y += SECTION_HEIGHT
   }

   for (key in starts) {
      for (t of texts) {
         for (k in t) {
            if (k == key) {
               for (ts of t[k]) {
                  ts.setAttribute('fill', starts[key].color)
                  ts.textContent = starts[key].value
               }
            }
         }
      }
   }

   background.setAttribute('height', (curr_y + BUFFER) - y);
}

function add_section(name, color, icon, x, y, img_width, rows) {
   loadImage(x, y, icon)
   var items = []
   __create_stats_page(x + img_width, y, 240, rows, name, color)
}

add_section(
   "chestpiece",
   "#f779f7",
   "./chestpiece.png",
   100,
   100,
   227,
   [
      { type:"text", color:"#696969", value:"Quality: ${quality}%" },
      { type:"slider", id:"quality", min:0, max:20, default:20, color:"#5bfee0" },

      { type:"text", color:"#696969", value:"Base Energy Shield: ${base_value}" },
      { type:"slider", id:"base_value", min:12, max:47, default:36, color:"#00ff00" },

      { type:"text", color:"#7171da", value:"+${flat_add} to Maximum Energy Shield" },
      { type:"slider", id:"flat_add", min:16, max:30, default:21, color:"#fe3521" },

      { type:"text", color:"#7171da", value:"${perc_incr}% Increased Energy Shield" },
      { type:"slider", id:"perc_incr", min:20, max:109, default:54, color:"#f2fc24" },

      { type:"gap" },

      { type:"text", color:"#696969", value:"Floor[ (${base_value} + ${flat_add}) * ${perc_incr_f} * ${quality_f} ]" },
      { type:"text", color:"#696969", value:"Item Energy Shield: ${chestpiece}" },

      { type:"calc", id:"quality_f", from:["quality"], func:(p)=>(1.0 + p/100.0).toFixed(2) },
      { type:"calc", id:"perc_incr_f", from:["perc_incr"], func:(p)=>(1.0 + p/100.0).toFixed(2) },
      { type:"calc", id:"chestpiece", from:["base_value","flat_add","perc_incr_f","quality_f"], func:(b,f,p,q)=>Math.floor((b+f)*p*q) }
   ]
)

add_section(
   "int",
   "#f779f7",
   "./int.png",
   650,
   100,
   34,
   [
      { type:"text", color:"#696969", value:"Intelligence: ${amount}" },
      { type:"slider", id:"amount", min:0, max:500, default:124, color:"#5bfee0" },

      { type:"gap" },

      { type:"text", color:"#696969", value:"Floor[ ${amount} / 10 * 2 ]" },
      { type:"text", color:"#696969", value:"${int}% Increased Max Energy Shield" },

      { type:"calc", id:"int", from:["amount"], func:(a)=>Math.floor(a / 10.0 * 2) },
   ]
)

   </script>
</body>
</html>