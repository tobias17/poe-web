<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <title>SVG Canvas Helper</title>
   <style>
      body {
         background-color: #242424;
         margin: 0;
         padding: 0;
         display: flex;
         justify-content: center;
         font-family: Arial, sans-serif;
      }
      #svg-container {
         width: 100%;
         max-width: 1200px;
         position: fixed;
         top: 0;
         left: 0;
         right: 0;
         margin: 0 auto;
      }
      svg {
         width: 100%;
         height: auto;
      }
      .svg_text {
         -webkit-user-select: none;
         -moz-user-select: none;
         -ms-user-select: none;
         user-select: none;
      }
   </style>
</head>
<body>
   <div id="svg-container">
      <svg id="canvas" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1400 800">
         <!-- Elements will be dynamically added here -->
      </svg>
   </div>

   <script>

// Get the SVG canvas
const canvas = document.getElementById('canvas');
const print = console.log

var selected_slider = null
function global_on_mouse_move(e) {
   if (selected_slider == null) {
      return
   }
   if (!e.buttons) {
      selected_slider = null
      return
   }
   const g = selected_slider
   const CTM = canvas.getScreenCTM();
   const mouse_x = (e.clientX - CTM.e) / CTM.a
   const perc = Math.max(0.0, Math.min(1.0, (mouse_x- g.lx) / g.dx))
   const index = Math.floor(perc * g.range + 0.5)
   const cx = g.lx + g.dx * (index / g.range)
   for (knob of g.knobs) {
      knob.setAttribute("cx", cx)
   }
   g.update_data(index + g.min)
}
canvas.onmousemove = global_on_mouse_move



/************************/
/***    Common Lib    ***/
/************************/
function loadImage(x, y, href) {
   const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
   image.setAttribute('x', x);
   image.setAttribute('y', y);
   image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', href);
   canvas.appendChild(image);
   return image;
}
function group(x, y, attrs={}) {
   return Object.assign(attrs, {
      tag: 'g',
      x: x,
      y: y,
   })
}
function circle(cx, cy, r, color, attrs={}) {
   return Object.assign(attrs, {
      tag: 'circle',
      cx: cx,
      cy: cy,
      r: r,
      fill: color,
   })
}
function rectangle(x, y, w, h, color, attrs={}) {
   return Object.assign(attrs, {
      tag: 'rect',
      x: x,
      y: y,
      width: w,
      height: h,
      fill: color,
   })
}
function tspan(color, attrs={}) {
   return Object.assign(attrs, {
      tag: 'tspan',
      fill: color,
   })
}
function create(attrs, parent=null) {
   const item = document.createElementNS('http://www.w3.org/2000/svg', attrs.tag);
   for (key in attrs) {
      if (key != "tag") item.setAttribute(key, attrs[key])
   }
   (parent == null ? canvas : parent).appendChild(item);
   return item;
}



const FONT_SIZE = 14
function sfc32(a, b, c, d) {
   return function() {
      a |= 0; b |= 0; c |= 0; d |= 0;
      let t = (a + b | 0) + d | 0;
      d = d + 1 | 0;
      a = b ^ b >>> 9;
      b = c + (c << 3) | 0;
      c = (c << 21 | c >>> 11);
      c = c + t | 0;
      return (t >>> 0) / 4294967296;
   }
}
function seed_rng(text) {
   const h = []
   for (let shft = 3; shft < 7; shft++) {
      var hash = 0
      if (text.length == 0) return sfc32(0, 1, 2, 3)
      for (i = 0; i < text.length; i++) {
         hash = ((hash << shft) - hash) + text.charCodeAt(i) | 0
      }
      h.push(hash)
   }
   return sfc32(...h)
}
function shuffle(list, rng) {
   const values = list.slice()
   const order = []
   while (values.length > 0) {
      order.push(values.splice(Math.floor(rng() * values.length), 1)[0])
   }
   return order
}
function evenly_space(amount, rng, offset=null) {
   offset = offset == null ? rng() : offset
   const values = []
   for (let i = 0; i < amount; i++) {
      const v = offset + (i/amount)
      values.push(v > 1.0 ? v - 1.0 : v)
   }
   return shuffle(values, rng)
}

const HUE_START = -70
const HUE_END   = 210
function rotate(value, amount) {
   const sum = value + amount
   return sum - Math.floor(sum)
}
function norm_index(value, range, start=0) {
   return start + Math.round(rotate((value - start) / range))
}
function fill_single_anchor(anchor, amount, rng) {
   const percs = evenly_space(amount, rng, anchor)
   const delta = anchor - percs[0]
   for (i in percs) {
      percs[i] = rotate(percs[i], delta)
   }
   return percs
}
function percs_to_hsvs(percs, local=true) {
   const values = []
   for (perc of percs) {
      var hue = HUE_START + perc * (HUE_END - HUE_START)
      if (hue < 0) hue += 360
      values.push(`hsl(${Math.round(hue)}deg, 92%, ${local ? 75 : 8}%)`)
   }
   return values
}
function anchor_to_local_hsvs(anchor, name, amount) {
   return percs_to_hsvs(fill_single_anchor(anchor, amount, seed_rng(name)))
}
function multi_anchor_to_local_hsvs(anchors, name, amount) {
   var indeces = []
   for (a of anchors) {
      indeces.push(Math.floor(a * amount))
   }
   const HALF_STEP = 0.5 * (1 / amount)
   function spread_out() {
      for (oi in indeces) {
         for (ii in indeces) {
            if (oi == ii) continue
            const ov = indeces[oi]
            const iv = indeces[ii]
            if (ov == iv) {
               const center = ov * amount + HALF_STEP
               const od = Math.abs(anchors[oi] - center)
               const id = Math.abs(anchors[ii] - center)

               const has_left  = norm_index(ov - 1, amount) in indeces
               const has_right = norm_index(ov + 1, amount) in indeces
               var dir = 0
               if ( has_left && !has_right) dir =  1
               if (!has_left &&  has_right) dir = -1
               if (od > id) {
                  if (dir == 0) dir = Math.sign(anchors[oi] - anchors[ii])
                  indeces[oi] = norm_index(indeces[oi] + dir, amount)
               } else {
                  if (dir == 0) dir = Math.sign(anchors[ii] - anchors[oi])
                  indeces[ii] = norm_index(indeces[ii] + dir, amount)
               }
               return false
            }
         }
      }
      return true
   }
   var ok
   while (!ok) {
      ok = spread_out()
   }

   const spaces = []
   for (let i = 0; i < amount; i++) {
      var found = false
      for (let j = 0; j < indeces.length; j++) {
         if (i == indeces[j]) {
            found = true
            break
         }
      }
      if (!found) {
         spaces.push(i)
      }
   }
   const percs = []
   for (a of anchors) {
      percs.push(a)
   }
   const order = shuffle(spaces, seed_rng(name))
   for (o of order) {
      percs.push(o / amount + HALF_STEP)
   }

   const values = []
   for (perc of percs) {
      var hue = HUE_START + perc * (HUE_END - HUE_START)
      if (hue < 0) hue += 360
      values.push(`hsl(${Math.round(hue)}deg, 92%, 75%)`)
   }
   return values
}


var first_time = []
var curr_vals = {}
var stat_subs = {}
function add_sub(key, value) {
   if ( !(key in stat_subs) ) {
      stat_subs[key] = []
   }
   stat_subs[key].push(value)
}

/*************************/
/***  Slider Elements  ***/
/*************************/
function __create_slider(cx, cy, width, min, max, color, value) {
   const SLIDER_RADIUS = 2.5
   const SLIDER_COLOR  = "#242424"
   const KNOB_RADIUS   = 9
   const KNOB_COLOR    = "#696969"

   const lx = cx-width/2
   const rx = cx+width/2
   create(rectangle(lx, cy-SLIDER_RADIUS, width, 2*SLIDER_RADIUS, SLIDER_COLOR))
   create(circle(lx, cy, SLIDER_RADIUS, SLIDER_COLOR))
   create(circle(rx, cy, SLIDER_RADIUS, SLIDER_COLOR))

   const vx = lx + (rx - lx) * ((value - min) / (max - min))

   const g = create(group(0, 0))
   const knob_outer = create(circle(vx, cy, KNOB_RADIUS, KNOB_COLOR), g)
   const knob_inner = create(circle(vx, cy, SLIDER_RADIUS, color), g)
   g.onmousedown = () => (selected_slider = g)
   g.min = min
   g.range = (max-min)
   g.lx = lx
   g.dx = (rx-lx)
   g.knobs = [knob_outer, knob_inner]
   return g
}

/*************************/
/***   Text Elements   ***/
/*************************/
function __create_text_elements(text, x, y, font_size, color, global_name) {
   const text_element = document.createElementNS('http://www.w3.org/2000/svg', 'text');
   text_element.setAttribute('x', x);
   text_element.setAttribute('y', y);
   text_element.setAttribute('text-anchor', 'middle');
   text_element.setAttribute('dominant-baseline', 'middle');
   text_element.setAttribute('font-size', font_size);
   text_element.setAttribute('class', 'svg_text')
   canvas.appendChild(text_element);

   var original = text
   var in_section = false
   while (text.length > 0) {
      if (in_section) {
         var index = text.indexOf("}")
         if (index < 0) {
            console.error(`unmatched brackets: '${original}'`)
            return null
         }
         var id = text.slice(0, index)
         const fmt_index = id.indexOf(":")
         var fmt_func = (v) => (v)
         if (fmt_index > 0) {
            const fmt_str = id.slice(fmt_index+1)
            if (fmt_str.length != 1) {
               console.error(`Expect exactly 1 format character, got '${fmt_str}' from '${id}'`)
               return null
            }
            const amnt = parseInt(fmt_str, 10)
            fmt_func = (v) => (v.toFixed(amnt))
            id = id.slice(0, fmt_index)
         }

         const key = id.indexOf(".") < 0 ? `${global_name}.${id}` : id
         const t = create(tspan(color), text_element)
         t.textContent = `[${key}]`
         const frozen_fmt_func = fmt_func
         function update_text() {
            const value = curr_vals[key]
            if (value === null || value === undefined) {
               return
            }
            t.textContent = frozen_fmt_func(value)
         }
         add_sub(key, update_text)
         first_time.push(() => t.setAttribute('fill', local_colors[key]))
         first_time.push(update_text)
         text = text.slice(index + 1)
         in_section = false
      } else {
         var index = text.indexOf("${")
         var chunk = index < 0 ? text : text.slice(0, index)
         const t = create(tspan(color), text_element)
         t.textContent = chunk
         text = index < 0 ? "" : text.slice(index + 2)
         in_section = true
      }
   }
}

/************************/
/***    Stats Page    ***/
/************************/
const local_colors = {}
function __create_stats_page(x, y, width, rows, global_name, global_color) {
   const SECTION_HEIGHT = 22
   var usable_width = width * 0.75
   const background = create(rectangle(x, y, width, 0, '#0f0f0f'))
   const cx = x + width/2
   const BUFFER = 0.3 * SECTION_HEIGHT

   function update_data(key, value) {
      if (value === null || value === undefined) {
         console.error(`Got null value for key '${key}'`)
         return
      }
      curr_vals[key] = value
      if (key in stat_subs) {
         for (sub of stat_subs[key]) {
            sub()
         }
      }
   }

   var curr_y = y + BUFFER + SECTION_HEIGHT
   for (row of rows) {
      const row_id = `${global_name}.${row.id}`
      if (row.type == "text") {
         __create_text_elements(row.value, cx, curr_y, FONT_SIZE, row.color, global_name)
      } else if (row.type == "slider") {
         const g = __create_slider(cx, curr_y, usable_width, row.min, row.max, row.color, row.default)
         g.update_data = (v) => update_data(row_id, v)
         curr_vals[row_id] = row.default
         local_colors[row_id] = row.color
      } else if (row.type == "calc") {
         const from_ids = row.from
         const from_keys = []
         for (id of from_ids) {
            from_keys.push(id.indexOf(".") < 0 ? `${global_name}.${id}` : id)
         }

         const func = row.func
         const color =
            "color" in row
               ? row.color
               : from_keys.length == 1
                  ? local_colors[from_keys[0]]
                  : null
         if (color == null) {
            console.error(`could not determine color for calc '${row_id}'`)
            continue
         }
         local_colors[row_id] = color

         function update_calc() {
            const params = []
            for (key of from_keys) {
               params.push(curr_vals[key])
            }
            const new_value = func(...params)
            if (new_value == null) {
               console.error(`got null result from ${row_id}, params=${params}`)
            } else {
               update_data(row_id, new_value)
            }
         }
         for (key of from_keys) {
            add_sub(key, update_calc)
         }
         curr_y -= SECTION_HEIGHT
      } else if (row.type == "gap") {
         // pass
      } else {
         console.error(`got invalid row['type'] value '${row.type}'`)
      }
      curr_y += SECTION_HEIGHT
   }

   background.setAttribute('height', (curr_y + BUFFER) - y)
   return (curr_y + BUFFER) - y
}

function add_section(name, color, icon, x, y, img_width, img_height, stats_width, rows) {
   BORDER_SIZE = 5
   create(rectangle(x-BORDER_SIZE, y-BORDER_SIZE, img_width + 2*BORDER_SIZE, img_height + 2*BORDER_SIZE, color))
   const r = create(rectangle(x+img_width, y-BORDER_SIZE, stats_width + 2*BORDER_SIZE, 0, color))
   loadImage(x, y, icon)
   var height = __create_stats_page(x+img_width+BORDER_SIZE, y, stats_width, rows, name, color)
   r.setAttribute('height', height + 2*BORDER_SIZE)
}





const GRAY_TEXT = "#696969"
const PURP_TEXT = "#7171da"

sections = evenly_space(5, seed_rng("witch"))
const global_colors = percs_to_hsvs(sections, false)

var colors = anchor_to_local_hsvs(sections.pop(), "chestpiece", 6)
var primary = colors.pop()
add_section(
   "chestpiece",
   global_colors.pop(),
   "./chestpiece.png",
   100,
   100,
   227,
   332,
   240,
   [
      { type:"text", color:GRAY_TEXT, value:"Quality: ${quality}%" },
      { type:"slider", id:"quality", min:0, max:20, default:20, color:colors.pop() },

      { type:"text", color:GRAY_TEXT, value:"Base Energy Shield: ${base_value}" },
      { type:"slider", id:"base_value", min:12, max:47, default:36, color:colors.pop() },

      { type:"text", color:PURP_TEXT, value:"+${flat_add} to Maximum Energy Shield" },
      { type:"slider", id:"flat_add", min:16, max:30, default:21, color:colors.pop() },

      { type:"text", color:PURP_TEXT, value:"${perc_incr}% Increased Energy Shield" },
      { type:"slider", id:"perc_incr", min:20, max:109, default:54, color:colors.pop() },

      { type:"gap" },

      { type:"text", color:GRAY_TEXT, value:"Floor[ (${base_value} + ${flat_add}) * ${perc_incr_f:2} * ${quality_f:2} ]" },
      { type:"text", color:GRAY_TEXT, value:"Item Energy Shield: ${energy_shield}" },

      { type:"calc", id:"quality_f", from:["quality"], func:(p)=>(1.0 + p/100.0) },
      { type:"calc", id:"perc_incr_f", from:["perc_incr"], func:(p)=>(1.0 + p/100.0) },
      { type:"calc", id:"energy_shield", color:primary, from:["base_value","flat_add","perc_incr_f","quality_f"], func:(b,f,p,q)=>Math.floor((b+f)*p*q) }
   ]
)

colors = anchor_to_local_hsvs(sections.pop(), "int", 2)
primary = colors.pop()
add_section(
   "int",
   global_colors.pop(),
   "./int.png",
   650,
   80,
   34,
   34,
   280,
   [
      { type:"text", color:GRAY_TEXT, value:"Intelligence: ${amount}" },
      { type:"slider", id:"amount", min:0, max:500, default:124, color:colors.pop() },

      { type:"gap" },

      { type:"text", color:GRAY_TEXT, value:"Floor[ ${amount} / 10 * 2 ]" },
      { type:"text", color:GRAY_TEXT, value:"${perc_incr}% Increased Max Energy Shield" },

      { type:"calc", id:"perc_incr", color:primary, from:["amount"], func:(a)=>Math.floor(a / 10.0 * 2) },
   ]
)
colors = multi_anchor_to_local_hsvs([sections.pop(), sections.pop()], "helmet", 4)
var primaries = [colors.pop(), colors.pop()]
add_section(
   "helmet",
   global_colors.pop(),
   "./helmet.png",
   940,
   280,
   206,
   231,
   240,
   [
      { type:"text", color:GRAY_TEXT, value:"Quality: ${quality}%" },
      { type:"slider", id:"quality", min:0, max:20, default:20, color:colors.pop() },

      { type:"text", color:GRAY_TEXT, value:"Base Energy Shield: ${base_value}" },
      { type:"slider", id:"base_value", min:12, max:47, default:36, color:colors.pop() },

      { type:"text", color:PURP_TEXT, value:"${global_perc_incr}% Increased Global Defenses" },
      { type:"slider", id:"global_perc_incr", min:18, max:22, default:20, color:primaries.pop() },

      { type:"gap" },

      { type:"text", color:GRAY_TEXT, value:"Floor[ ${base_value} * ${quality_f:2} ]" },
      { type:"text", color:GRAY_TEXT, value:"Item Energy Shield: ${energy_shield}" },

      { type:"calc", id:"quality_f", from:["quality"], func:(p)=>(1.0 + p/100.0) },
      { type:"calc", id:"energy_shield", color:primaries.pop(), from:["base_value","quality_f"], func:(b,q)=>Math.floor(b*q) },
   ]
)

colors = anchor_to_local_hsvs(sections.pop(), "helmet", 1)
primary = colors.pop()
add_section(
   "character",
   global_colors.pop(),
   "./witch.png",
   400,
   480,
   201,
   264,
   280,
   [
      { type:"text", color:GRAY_TEXT, value:"Floor[ (${chestpiece.energy_shield} + ${helmet.energy_shield}) * (1.0 + ${int_perc_incr_f:2} + ${helmet_perc_incr_f:2}) ]" },
      { type:"text", color:GRAY_TEXT, value:"Character Energy Shield: ${energy_shield}" },

      { type:"calc", id:"int_perc_incr_f", from:["int.perc_incr"], func:(p)=>(p/100.0) },
      { type:"calc", id:"helmet_perc_incr_f", from:["helmet.global_perc_incr"], func:(p)=>(p/100.0) },
      { type:"calc", id:"energy_shield", color:primary, from:["chestpiece.energy_shield","helmet.energy_shield","int_perc_incr_f","helmet_perc_incr_f"], func:(cf,hf,ip,hp)=>Math.floor((cf+hf)*(1.0+ip+hp)) },
   ]
)

for (func of first_time) {
   func()
}
for (key in stat_subs) {
   for (sub of stat_subs[key]) {
      sub()
   }
}


   </script>
</body>
</html>